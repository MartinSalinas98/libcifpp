//          Copyright Maarten L. Hekkelman 2006-2010
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef MRSRC_H
#define MRSRC_H

#include <string>
#include <list>
#include <exception>

namespace mrsrc
{

class rsrc_not_found_exception : public std::exception
{
  public:
    virtual const char* what() const throw()		{ return "resource not found"; }
};

class rsrc;
typedef std::list<rsrc>	rsrc_list;

}

// --------------------------------------------------------------------
// By default, we assume mrc is used to create the resources. If you need
// local disk storage instead, use the NO_RSRC macro. See below for
// usage.

#if defined(USE_RSRC)

/*
	Resources are data sources for the application.
	
	They are retrieved by name.

	Basic usage:
	
	mrsrc::rsrc rsrc("dialogs/my-cool-dialog.glade");
	
	if (rsrc)
	{
		GladeXML* glade = glade_xml_new_from_buffer(rsrc.data(), rsrc.size(), NULL, "japi");
		
		...
	}
*/

namespace mrsrc {
	struct rsrc_imp
	{
		unsigned int	m_next;
		unsigned int	m_child;
		unsigned int	m_name;
		unsigned int	m_size;
		unsigned int	m_data;
	};
}

// The following three variables are generated by the japi resource compiler:

extern const mrsrc::rsrc_imp	gResourceIndex[];
extern const char				gResourceData[];
extern const char				gResourceName[];

namespace mrsrc
{

class rsrc
{
  public:
						rsrc() : m_impl(gResourceIndex) {}

						rsrc(const rsrc& other)
							: m_impl(other.m_impl) {}

	rsrc&				operator=(const rsrc& other)
						{
							m_impl = other.m_impl;
							return *this;
						}
	
						rsrc(const std::string& path);

	std::string			name() const			{ return gResourceName + m_impl->m_name; }

	const char*			data() const			{ return gResourceData + m_impl->m_data; }
	
	unsigned long		size() const			{ return m_impl->m_size; }

						operator bool () const	{ return m_impl != NULL and m_impl->m_size > 0; }

	rsrc_list			children() const;

  private:

						rsrc(const rsrc_imp* imp)
							: m_impl(imp) {}

	const rsrc_imp*		m_impl;
};

inline
rsrc_list rsrc::children() const
{
	rsrc_list result;
	
	if (m_impl->m_child)
	{
		const rsrc_imp* impl = gResourceIndex + m_impl->m_child;
		result.push_back(rsrc(impl));
		while (impl->m_next)
		{
			impl = gResourceIndex + impl->m_next;
			result.push_back(rsrc(impl));
		}
	}
	
	return result;
}

inline
rsrc::rsrc(const std::string& path)
{
//	static_assert(sizeof(m_impl->m_next) == 4, "invalid size for unsigned int");
	
	m_impl = gResourceIndex;
	
	std::string p(path);
	
	// would love to use boost functions here, but then the dependancies
	// should be minimal of course.
	while (not p.empty())
	{
		if (m_impl->m_child == 0)	// no children, this is an error
			throw rsrc_not_found_exception();

		m_impl = gResourceIndex + m_impl->m_child;
		
		std::string::size_type s = p.find('/');
		std::string name;
		
		if (s != std::string::npos)
		{
			name = p.substr(0, s);
			p.erase(0, s + 1);
		}
		else
			std::swap(name, p);
		
		while (name != gResourceName + m_impl->m_name)
		{
			if (m_impl->m_next == 0)
				throw rsrc_not_found_exception();
			m_impl = gResourceIndex + m_impl->m_next;
		}
	}
}

}

#else

// --------------------------------------------------------------------
// Fall back option for resources, locate the data in the path specified
// in then environment variable RESOURCE_DIR

#include <cstdlib>
#include <unistd.h>

#include <iostream>
#include <fstream>
#include <vector>
#include <map>

namespace mrsrc
{

namespace detail
{

class rsrc_loader
{
  public:

	static rsrc_loader& instance()
	{
		static rsrc_loader sInstance;
		return sInstance;
	}

	const std::vector<char>& load(const std::string& path)
	{
		if (not m_loaded.count(path))
		{
			std::string p = m_rsrc_dir + '/' + path;
			
			std::ifstream file(p);
			std::vector<char> result;

			if (file.is_open())
			{
				std::streambuf* b = file.rdbuf();
				size_t length = b->pubseekoff(0, std::ios::end);
				b->pubseekpos(0);

				result.resize(length);
				b->sgetn(result.data(), length);
			}

			m_loaded.emplace(path, std::move(result));
		}

		return m_loaded.at(path);
	}

  private:

	rsrc_loader()
	{
		const char* rsrc_dir = getenv("RESOURCE_DIR");
#if defined(RSRC_DIR)
		if (rsrc_dir == nullptr)
			rsrc_dir = RSRC_DIR;
#endif
		if (rsrc_dir == nullptr)
		{
			char pb[PATH_MAX];
			const char* cwd = getcwd(pb, PATH_MAX);

			if (cwd == nullptr)
				throw std::runtime_error("Could not locate resource directory nor current directory");

			std::cerr << "RESOURCE_DIR not defined, falling back to " << cwd << std::endl;

			rsrc_dir = cwd;
		}

		m_rsrc_dir = rsrc_dir;
	}

	std::string m_rsrc_dir;
	std::map<std::string,std::vector<char>> m_loaded;
};

}

class rsrc
{
  public:
	rsrc(const rsrc&) = delete;
	rsrc& operator=(const rsrc&) = delete;

	rsrc(const std::string& path)
		: m_data(detail::rsrc_loader::instance().load(path))
		// , m_name(path)
	{}

	// std::string			name() const			{ return m_name; }

	const char*			data() const			{ return m_data.data(); }
	
	unsigned long		size() const			{ return m_data.size(); }

	explicit			operator bool () const	{ return not m_data.empty(); }

	// rsrc_list			children() const;

  private:

	const std::vector<char>&	m_data;
	// const std::string			m_name;
};

}

#endif

#endif
